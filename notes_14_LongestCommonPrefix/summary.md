### 最长公共前缀

#### 题目

编写一个函数来查找字符串数组中的最长公共前缀。

如果不存在公共前缀，返回空字符串 `""`。

**示例 1:**

```
输入: ["flower","flow","flight"]
输出: "fl"
```

**示例 2:**

```
输入: ["dog","racecar","car"]
输出: ""
解释: 输入不存在公共前缀。
```

**说明:**

所有输入只包含小写字母 `a-z` 。

#### 解题思路

1. 最长公共前缀，首先想到了，先定义一个字符串，取数组中第一个字符串的第一个字符赋值，
2. 然后依次判断字符串数组中的所有元素，是否是以该字符串为开头的，
3. 如果是，则在该字符串的末尾添加数组中第一个字符串的第二个字符
4. 如果不是，则去掉该字符串的最后一个字符。返回该字符串。

#### 不足之处

1. 最初提交的时候，没有考虑到：
   1. 数组为空
   2. 数组只有一个元素，且该字符串只有一个字符
   3. 数组只有一个元素，且该字符串为空串
   4. 这几个特殊情况
2. 代码较为复杂，若从多往少比较，则会简洁很多

#### 代码

1. 最优

   ```java
   class Solution {
       public static String longestCommonPrefix(String[] strs) {
           int count = strs.length;
           String prefix = "";
           if(count != 0){
               prefix = strs[0];
           }
           for(int i=0; i<count; i++){
               //关键代码，不断的从后往前截取字符串，然后与之相比，直到startsWith()返回true
               while(!strs[i].startsWith(prefix)){
                   prefix = prefix.substring(0, prefix.length()-1);
               }
           }
           return prefix;
       }
   }
   ```

   - 此方法代码容易理解，思路更加清晰
   - 兼顾了好几种特殊情况的处理。

### 总结

1. 遇到类似的题目，可以尝试从前往后遍历，和从后往前遍历，两种方法，比较哪种方法较为简洁。
2. 看到题目，要先想想特殊情况的特殊处理，再优化对特殊情况的处理方式。
